# -*- coding: utf-8 -*-
"""tx_月合約全日k_gspread__v04_1150227editting_完成_註解.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16YoUQPnlku63IbKiABeo-22dKPBOh2dg

# 程式碼總結說明：


此程式的主要目的是將台指期貨的每日交易數據，
整理成「以合約為單位」的摘要資訊，包含：
 - 每個合約的開倉日期與開盤價
- 合約期間的最高價與最低價
- 合約的收盤日期與收盤價

處理流程：
1. 下載原始數據
2. 過濾出近月合約的一般盤與盤後交易
3. 合併每日的盤中與盤後數據
4. 標記每個合約的開倉/持有/平倉狀態
5. 統計每個合約的關鍵價格資訊
6. 輸出整理好的合約摘要表
"""

# ============================================================
# 步驟 1：安裝 FinMind 並下載台指期（TX）日線資料
# ============================================================


from FinMind.data import DataLoader

dl = DataLoader()

# 從 2023-12-22 起下載 TX 台指期所有合約的日線資料
future_data = dl.taiwan_futures_daily(futures_id='TX', start_date='2023-12-22')

import pandas as pd

# ============================================================
# 步驟 2：資料清洗 — 篩選有效交易資料
# ============================================================
# 只保留「盤中(position)」和「盤後(after_market)」兩種交易時段
future_data = future_data[future_data['trading_session'].isin(["position", "after_market"])]

# 只保留月合約（contract_date 長度 <= 6，例如 "202401"）
future_data = future_data[future_data['contract_date'].str.len() <= 6]

# ============================================================
# 步驟 3：每日取「近月合約」（contract_date 最小者即為近月）
# ============================================================
future_data = future_data[
    future_data['contract_date'] == future_data.groupby('date')['contract_date'].transform('min')
]

df2 = future_data

# ============================================================
# 步驟 4：依日期彙總 OHLC 資料
#   - open：優先取盤後(after_market)，無則取盤中(position)
#   - max / min：取當日兩時段的最高/最低
#   - close：優先取盤後(after_market)，無則取盤中(position)
# ============================================================
df = df2.groupby('date').apply(lambda x: pd.Series({
    'open': (
        x[x['trading_session'] == 'after_market']['open'].iloc[0]
        if any(x['trading_session'] == 'after_market')
        else x[x['trading_session'] == 'position']['open'].iloc[0]
        if any(x['trading_session'] == 'position') else None
    ),
    'max': x['max'].max(),
    'min': x['min'].min(),
    'close': (
        x[x['trading_session'] == 'after_market']['close'].iloc[0]
        if any(x['trading_session'] == 'after_market')
        else x[x['trading_session'] == 'position']['close'].iloc[0]
        if any(x['trading_session'] == 'position') else None
    ),
    'futures_id': (
        x[x['trading_session'] == 'after_market']['futures_id'].iloc[0]
        if any(x['trading_session'] == 'after_market')
        else x[x['trading_session'] == 'position']['futures_id'].iloc[0]
        if any(x['trading_session'] == 'position') else None
    ),
    'contract_date': (
        x[x['trading_session'] == 'after_market']['contract_date'].iloc[0]
        if any(x['trading_session'] == 'after_market')
        else x[x['trading_session'] == 'position']['contract_date'].iloc[0]
        if any(x['trading_session'] == 'position') else None
    ),
}), include_groups=False).reset_index()

# 重新排列欄位順序
df = df[['date', 'futures_id', 'contract_date', 'open', 'max', 'min', 'close']]
dfa = df

# ============================================================
# 步驟 5：標記每個月合約的「開倉日」「持有日」「結算日」
# ============================================================
extra = dfa.sort_values('date').reset_index(drop=True)

if 'contract_date' not in extra.columns:
    extra = extra.reset_index()

def label_contract_position(group):
    group = group.copy()
    group['contract_position'] = 'Hold'           # 預設為持有中
    group.loc[group.index[0], 'contract_position'] = 'Open'    # 第一筆為開倉日
    if len(group) > 1:
        group.loc[group.index[-1], 'contract_position'] = 'Close'  # 最後一筆為結算日
    return group

extra = extra.groupby('contract_date', group_keys=False).apply(label_contract_position)
extra = extra[['date', 'futures_id', 'contract_date', 'open', 'max', 'min', 'close', 'contract_position']]
dfb = extra
dfb

# ============================================================
# 步驟 6：依合約彙整月K資料（開倉/最高/最低/收盤/結算日期）
# ============================================================
# 篩出開倉與結算列
open_rows = dfb[dfb['contract_position'] == 'Open'].reset_index(drop=True)
close_rows = dfb[dfb['contract_position'] == 'Close'].reset_index(drop=True)

# 每個合約的整體最高與最低（全期間）
minmax_grouped = dfb.groupby('contract_date').agg(
    最高=('max', 'max'),
    最低=('min', 'min'),
).reset_index()

# 開倉資訊：開倉日期、商品名稱、開盤價
open_grouped = open_rows.groupby('contract_date').agg(
    開倉日期=('date', 'first'),
    商品名稱=('futures_id', 'first'),
    開盤=('open', 'first'),
).reset_index()

# 結算資訊：結算日期、收盤價
close_grouped = close_rows.groupby('contract_date').agg(
    收盤日期=('date', 'first'),
    收盤=('close', 'first'),
).reset_index()

# 合併三份資料為月K總表
mthA_Fx_contact_df = open_grouped \
    .merge(minmax_grouped, on='contract_date', how='left') \
    .merge(close_grouped, on='contract_date', how='left')

mthA_Fx_contact_df = mthA_Fx_contact_df.rename(columns={'contract_date': '合約名稱'})
mthA_Fx_contact_df = mthA_Fx_contact_df[['開倉日期', '商品名稱', '合約名稱', '開盤', '最高', '最低', '收盤', '收盤日期']]

dfc = mthA_Fx_contact_df
dfc

# ============================================================
# 步驟 7：初始化震幅相關欄位（後續將在 Cell 3 正式計算）
# ============================================================
mthA_Fx_contact_df['span'] = 0          # 震幅（最高 - 最低）
mthA_Fx_contact_df['cost'] = 0          # 成本中心（(最高 + 最低) / 2）
mthA_Fx_contact_df['20月均震幅'] = 0    # 近20月震幅的移動平均
mthA_Fx_contact_df['最小震幅'] = 0      # 近20月最小震幅
mthA_Fx_contact_df['小震幅'] = 0        # (最小震幅 + 平均震幅) / 2
mthA_Fx_contact_df['平均震幅'] = 0      # 同 20月均震幅
mthA_Fx_contact_df['大震幅'] = 0        # (最大震幅 + 平均震幅) / 2
mthA_Fx_contact_df['最大震幅'] = 0      # 近20月最大震幅

# 初步計算 span（收盤 - 開盤），後續 Cell 3 會重新以向量化方式計算
for index, row in mthA_Fx_contact_df.iterrows():
    mthA_Fx_contact_df.loc[index, 'span'] = row['收盤'] - row['開盤']

mthA_Fx_contact_df.head()

"""calculate rolling mean of 20ma and so on."""

# ============================================================
# 步驟 8：向量化計算震幅統計指標（近20月滾動）
# ============================================================

# 修正資料型別，避免計算錯誤
mthA_Fx_contact_df['cost'] = mthA_Fx_contact_df['cost'].astype(float)

# 震幅 = 當月最高 - 當月最低
mthA_Fx_contact_df['span'] = mthA_Fx_contact_df['最高'] - mthA_Fx_contact_df['最低']

# 成本中心 = (最高 + 最低) / 2，代表均衡價位
mthA_Fx_contact_df['cost'] = (mthA_Fx_contact_df['最高'] + mthA_Fx_contact_df['最低']) / 2

# 近20月平均震幅（min_periods=0 表示期數不足20也計算）
mthA_Fx_contact_df['20月均震幅'] = mthA_Fx_contact_df['span'].rolling(window=20, min_periods=0).mean().astype(int)

# 近20月最小、最大震幅
mthA_Fx_contact_df['最小震幅'] = mthA_Fx_contact_df['span'].rolling(window=20, min_periods=0).min()
mthA_Fx_contact_df['最大震幅'] = mthA_Fx_contact_df['span'].rolling(window=20, min_periods=0).max()

# 平均震幅（與 20月均震幅 相同，方便後續計算使用）
mthA_Fx_contact_df['平均震幅'] = mthA_Fx_contact_df['20月均震幅']

# 小震幅 = (最小震幅 + 平均震幅) / 2，代表偏低波動區間中值
mthA_Fx_contact_df['小震幅'] = (mthA_Fx_contact_df['最小震幅'] + mthA_Fx_contact_df['平均震幅']) / 2

# 大震幅 = (最大震幅 + 平均震幅) / 2，代表偏高波動區間中值
mthA_Fx_contact_df['大震幅'] = (mthA_Fx_contact_df['最大震幅'] + mthA_Fx_contact_df['平均震幅']) / 2

new_df2 = mthA_Fx_contact_df
new_df2

"""Transfer dataframe to google sheet"""

# ============================================================
# 步驟 9：安裝 Google Sheets 相關套件
#   - gspread：操作 Google Sheets API
#   - gspread_dataframe：將 pandas DataFrame 直接寫入 Google Sheets
# ============================================================


"""API key.json store in drive and shareed for downloading to Colad VM temperially by url, which doesn't go through drive authentication"""

import requests

# ============================================================
# 步驟 10：從 Google Drive 公開連結下載 Service Account 金鑰（JSON）
#   金鑰存放於 Google Drive（不儲存於 Colab，Session 結束即消失）
#   使用公開下載連結，不須通過 Drive 身份驗證
# ============================================================
url = "https://drive.google.com/uc?id=1PUo8axrWc0zOjTHE0f4zsRweVNGCcq6z&export=download"

response = requests.get(url)
if response.status_code == 200:
    with open("mtx-spreads-analysis-179ea8a41891.json", "wb") as file:
        file.write(response.content)
    print("File downloaded successfully.")
else:
    print(f"Failed to download file. HTTP status code: {response.status_code}")

# 設定 Service Account 金鑰檔路徑
SERVICE_ACCOUNT_FILE = 'mtx-spreads-analysis-179ea8a41891.json'

"""use key to transfer table to google sheet

the gsheet api KEY is permently store in google drive,/My drive/key

the dataset is transferred to the worksheet,Monthly, of spreadsheet,關卡價
"""

import pandas as pd
import gspread
from google.oauth2.service_account import Credentials
from gspread_dataframe import set_with_dataframe

# ============================================================
# 步驟 11：使用 Service Account 金鑰進行 Google API 身份驗證
# ============================================================
SERVICE_ACCOUNT_FILE = 'mtx-spreads-analysis-179ea8a41891.json'
SCOPES = ['https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive']
creds = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)

# 初始化 gspread 客戶端
client = gspread.authorize(creds)

# ============================================================
# 步驟 12：開啟目標 Google Sheets 並寫入月K資料
#   試算表：「關卡價」
#   工作表：「MonthlyAD」
# ============================================================
sheet_name = "關卡價"
spreadsheet = client.open(sheet_name)
worksheet = spreadsheet.worksheet("MonthlyAD")

# 清除工作表現有資料，避免舊資料殘留
worksheet.clear()

# 將 DataFrame（new_df2）寫入工作表，包含欄位標題
set_with_dataframe(worksheet, new_df2)

"""To trigger GAS web app to write data from MonthlyAD to 月 sheet of 關卡價"""

import requests

# ============================================================
# 步驟 13：觸發 Google Apps Script (GAS) Web App
#   GAS 負責將資料從 MonthlyAD 工作表
#   搬移/整合至「關卡價」的「周」工作表
# ============================================================
def trigger_gas_webapp():
    # GAS 已部署為 Web App 的執行 URL
    url = "https://script.google.com/macros/s/AKfycbxFLi4_yhfdsDGnEAYuqrj1aCbx8izUuWjtM-7pyQOnRUToiHfY6-e6FA3yQjKjCl47Cw/exec"

    try:
        # 發送 GET 請求觸發 GAS 執行
        response = requests.get(url)

        if response.status_code == 200:
            print("Request successful!")
            print("Response from GAS:", response.text)
        else:
            print(f"Request failed with status code {response.status_code}")
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    trigger_gas_webapp()
